\section{Тест производительности}


% \begin{longtable}{|p{7.5cm}|p{7.5cm}|}
%     \hline
%     \rowcolor{lightgray}
%     \multicolumn{2}{|c|} {Длина ключа от 1 до 3}\\
%     \hline
%     168616&PATRICIA\\
%     \hline
%     239682&Встроенная структура map\\
%     \hline
% \end{longtable}
Тест производительности будет проводится из консоли, где \texttt{bench} файл -- программа с наивной реализацией поиска по строке,
а \texttt{a.out}  -- программа с алгоритмом КМП. Тестирование производится с помощью утилиты \texttt{time}.
В тесте содержится 5000 строк, на каждой 100 случайных чисел.
Чтобы не засорять вывод ответами, я перенаправляю стандартный вывод в \texttt{/dev/null}.

\begin{alltt}
    sakost@sakost-pc ~/university/2 course/diskran/lab4$ time ./a.out < input.txt > /dev/null
./a.out < input.txt > /dev/null  5,07s user 0,02s system 99% cpu 5,089 total
sakost@sakost-pc ~/university/2 course/diskran/lab4$ time ./bench < input.txt > /dev/null
./bench < input.txt > /dev/null  8,15s user 0,30s system 99% cpu 8,461 total
\end{alltt}

Общее время работы в секундах указано последними числами: это \texttt{5.089} у КМП и \texttt{8.461} у наивной реализации соответственно.

Алгоритм КМП оказался чуть более, чем в полтора раза быстрее наивной реализации поиска даже на таких маленьких данных.
Т.к. генерация данных тоже занимает время, я не стал генерировать большее количество строк в тесте, поскольку данное количество вполне показательно.

Данный результат и следовало ожидать, поскольку сложность этих алгоритмов значительно отличается($O(n+m)$ у КМП и $O(nm)$ у наивного алгоритма, где $n$ - количество символов в тексте, а $m$ - количество символов в образце).
\pagebreak

