## Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Саженов К.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует два подхода к анализу и обработке языков: статистический и лингвистический.
Статистический метод, как следует из названия, ориентируется на статистические данные, а именно данный метод основывается на предположении о том, что содержание и смысл текста отражается в наиболее часто встречающихся словах.
Лингвистический же метод базируется на разных видах лингвистического анализа, который состоит из четырех уровней анализа данных, поступающих на ввод: графематический(выделение отдельных слов), морфологический(выделение признаков/характеристик отдельных слов), синтаксический(знаки препинания и проч. зависимости слов в предложении) и семнатический(более высокоуровенвый анализ - выделяет смысл высказывания).

Задача грамматического разбора и анализа естественных и искусственных языков является одной из самых распространенных задач, решаемых языками логического программирования. Простота разбора обусловлена естественностью реализации процесса переборов с возвратами, а также с удобством манипулирования символьной информацией.

Язык проргаммирования Prolog обладает ярковыраженными преимуществами по возможности сопоставления объектов с эталоном(англ. термин - Pattern matching), поэтому данный язык упрощает обработку естественных текстов. На Prolog с меньшим количеством затрат ресурсов можно реализовывать разного вида редакторы языка, трансляторы и т.п. В данном языке по умолчанию встроена стратегия backtracking-а ("обратного хода"), которая с большим успехом справляется с разбиением более большой части слова на более маленькие, атомарные части или же более низкоуровневые подцели и правила, которые, в свою очередь, также делятся на ещё более примитивные составные части, что делает язык Prolog максимально удобным под данную задачу.

## Задание

Реализовать морфологический разбор глаголов: {выучил, учила, изучили, обучил, ...}. Результат должен содержать сведения о роде и числе.

## Принцип решения

Данное решение производит сегментацию слова, путем подбора таких префиксов, суффиксов и окончаний(на самом деле аффиксов), чтобы "подходить" под существующие правила существования данных частей слова.

В самом начале производится преобразование строки в список, если была подана строка и, если был подан список, ничего не происходит:
```prolog
convert_string([], []).
convert_string("", []).
convert_string(X, X) :- is_list(X).
convert_string(X, Res) :- string_chars(X, Res).
```

Затем происходит поиск префикса в данном слове. Производится подстановка и, если ничего не получилось, добавляем один символ к префиксу и повторяем действия, пока не кончится список символов:
```prolog
find_prefix([_|[]], pref(""), _):-!.
find_prefix([P|Word], pref(P), Word):-
    prefix(P).
find_prefix([H, H1|Word], pref(Pref), RemWord):-
    string_concat(H, H1, NewPref),
    append([NewPref], Word, NewWord),
    find_prefix(NewWord, pref(Pref), RemWord).
```

После ищем окончание слова - проверяем является ли последняя строка в списке окончанием. Конкатенируем последнюю строку с предыдущими в списке. Параллельно с этим находим остаток слова:
```prolog
find_ending([_|[]], end(""), gen("М"), form("ед"), _):-!.
find_ending(Word, end(End), Gen, Num, Rem):-
    last(Word, End),
    without_last_letter(Word, Rem),
    ending(End, Gen, Num).
find_ending(Word, end(E), Gen, Num, RemWord):-
    last(Word, End),
    without_last_letter(Word, Rem),
    last(Rem, End2),
    without_last_letter(Rem, Rem2),
    string_concat(End2, End, NewEnd),
    append(Rem2, [NewEnd], NewWord),
    find_ending(NewWord, end(E), Gen, Num, RemWord).
```

Затем происходит поиск суффикса. Все аналогично поиску окончания:
```prolog
find_suffix([_|[]], suf(""), _):-!.
find_suffix(Word, suf(Suffix), Rem):-
    last(Word, Suffix),
    without_last_letter(Word, Rem),
    suffix(Suffix).
find_suffix(Word, suf(S), RemWord):-
    last(Word, Suffix),
    without_last_letter(Word, Rem),
    last(Rem, Suffix2),
    without_last_letter(Rem, Rem2),
    string_concat(Suffix2, Suffix, NewSuffix),
    append(Rem2, [NewSuffix], NewWord),
    find_suffix(NewWord, suf(S), RemWord).
```

Затем, т.к. `Root` так и остался списком символов, его следует преобразовать в строку:
```prolog
string_join([], Res, Res).
string_join([L | Tail], R, Res) :- string_concat(R, L, Res1), string_join(Tail, Res1, Res).
```

## Результаты

Результат работы программы(хочу обратить внимание на последний пример, т.к. там вводится сразу список символов):

```prolog
?- get_morphem("выучила", X).
X = morf(pref("вы"), root("уч"), end("ила"), genus("Ж"), form("ед")).

?- get_morphem("выучил", X).
X = morf(pref("вы"), root("уч"), end("ил"), genus("М"), form("ед")).

?- get_morphem("изучили", X).
X = morf(pref("из"), root("уч"), end("или"), genus("НЕТ"), form("мн")).

?- get_morphem("заучил", X).
X = morf(pref("за"), root("уч"), end("ил"), genus("М"), form("ед")).

?- get_morphem("обучило", X).
X = morf(pref("об"), root("уч"), end("ило"), genus("Ср"), form("ед")).

?- get_morphem(["о", "б", "у", "ч", "и", "л", "о"], X).
X = morf(pref("об"), root("уч"), end("ило"), genus("Ср"), form("ед")).
```


## Выводы

В данной лаборатороной работе я узнал о том, как обрабатываются простым способом естественные языки в NLP, закрепил работу со списками, а также понял, на сколько сложная задача - анализ естественного текста.

Также, в моей реализации присутствует предположение о том, что найденные приставка, суффикс и окончание(аффикс) - единственно возможные, что, естественно, чаще всего не является правдой, однако в рамках данной лабораторной работы мне показалось, что данного приема вполне хватит, поскольку он позволяет довольно полно анализировать широкий спектр слов. В более современных и близких к реальности системах, полагаю, стоит заранее идентифицировать род и число(в моей программе данные свойства идентифицируются из окончаний(они же, в данном случае, аффиксы), то есть определение данных характеристик происходит "на лету"), а затем уже проводить, т.н. "стемминг" и осуществлять разбор слова на морфемы.

Также хочу выделить то, что в задании указаны лишь прошедшие времена, что сильно упрощает задачу сбора базы данных для данной программы. Поскольку русский язык является одним из самых "богатых" языков(в понимании сложности языка), и окончаний не на прошедшие времена существует довольно много, в то время как для этого времени необходимо собрать лишь пару десятков окончаний и все будет работать успешно. Также, я не реализовывал идентефикацию корней по предикатам, поскольку в русском языке существует огромное количество различных корней и в данной работе проще было искать корень по "методу исключения".

Для улучшения данной программы стоит добавить некоторые условия для избавления от вывода "мусора", который может не нести никакой полезной информации в данном слове(например, когда отсутствует род, `genus("НЕТ")` можно было бы и не выводить).

Prolog является, несомненно, довольно мощным инструментом для решения некоторого рода задач в процессе, т.н. "research-инга", и предлагает много новых возможностей написания программ, в частности, возможность "быстрого" написания синтаксического разбора некоторого текста, однако, как мне кажется, конкретно Prolog не может являться основным языком в системах, где требуется скорость и емкость вычислений из-за своей скорости выполнения и неоптимизированности. Также хотелось бы выделить некоторую сложность задания базы данных для программ, поскольку все данные приходится вбивать в текст программы и его трудно отделить от "логики" этой же программы.

