# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Саженов К.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я получил навыки работы с генеалогическими деревьями в формате GEDCOM, парсинга различных файлов на одном языке скриптов bash. Затем научился обрабатывать графы связей между родственниками на Прологе: определять степень родства между двумя людьми, реализовывать естесственно-языковой интерфейс в системе логического программирования, используя синтаксис DCG.


## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предикатов `parent(родитель, ребенок)`, `sex(человек, m/f)`.
 3. Реализовать предикат проверки/поиска тещи.
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Я зарегестрировался на сервисе MyHeritage.com, создал свое родословное дерево, в нем оказалось 350 человек. Потом я экспортировал дерево из этого сервиса в формате GEDCOM.

## Конвертация родословного дерева

Я реализовал парсер формата GEDCOM с помощью языка bash. Данный скрипт принимает в качестве аргумента - файл, из которого будут считываться данные(либо же используется файл по умолчанию). Затем данные считываются по-строчно, добавляя людей по их id в словарь `people`:
```bash
declare -A people=()
```
По-строчное считывание:
```bash
# reading line by line ged file
while IFS="" read -r line || [ -n "$line" ]
```
Преобразование строки в массив:
```bash
params=($line)
len=${#params[@]}
```
Если длина массива меньше 3-х, значит полезной информации в строке нет(исходя из спецификации формата)
```bash
# skip line if there are too few arguments
if (( $len < 3)) ; then
    continue;
fi
```
Если строка указывает на человека, то парсим его id, и остальные данные:
```bash
attr="${params[2]//[$'\r\n']}"
# if we found a person
if [[ $attr == "INDI" ]] ; then
```
Сохраняем человека и выводим на экран его пол:
```bash
people[$id]="$givn_name"
echo "sex(${people[$id]}, ${sex,,})."
```
В случае, если аттрибут указывает на ребенка, пропускаем одну строку и считываем отца ребенка и его мать:
```bash
# found relation
elif [[ $attr == "FAM" ]] ; then
    read -r line
    read -r line
    params=($line)
    husb=""
    wife=""
    if [[ "$(strip_str ${params[1]})" == "HUSB" ]]; then
        h_id=$(str_to_id $(strip_str ${params[2]}))
        husb="${people[$h_id]}"
        read -r line
        params=($line)
    fi
    if [[ "$(strip_str ${params[1]})" == "WIFE" ]]; then
        w_id=$(str_to_id $(strip_str ${params[2]}))
        wife="${people[$w_id]}"
        read -r line
        params=($line)
    fi
```
Затем добавляем детей:
```bash
while [ -n "$line" ]
do
    params=($line)
    if [[ "$(strip_str ${params[1]})" != "CHIL" ]]; then
        break;
    fi
    id=$(str_to_id "$(strip_str "${params[2]}")") # convert id to integer
    if [ -n "$wife" ] ; then
        echo "parent(${wife}, ${people[$id]})."
    fi
    if [ -n "$husb" ] ; then
        echo "parent(${husb}, ${people[$id]})."
    fi
    IFS="" read -r line
done
```
И в цикл мы перенаправляем текст из файла, указанного в самом начале:
```bash
done <${ged_filename}
```

## Предикат поиска родственника
Для реализации поиска тещи, я реализовал предикат `motherinlaw`:
```prolog
% Num. 3
% 6 option. mother-in-law
motherinlaw(X, Y) :- 
    % determine a gender of the target
    sex(X, m),
    % find a child of the target(to determine wife)
    parent(X, Z),
    % find a wife(by finding a second parent of child of the target)
    parent(W, Z),
    sex(W, f),
    % clip backprop to not to use another children
    !,
    % find her(wife) parent(mother)
    parent(Y, W),
    % determine a gender to find out the mother-in-law
    sex(Y, f).
```
Дополнительные комментарии излишни, т.к. оные присутствуют в исходном коде.

Пример запроса:
```prolog
?- motherinlaw("Станислав_Саженов", A).
A = "Александра_Тавторкина" ;
false.

?- motherinlaw(A, "Александра_Тавторкина").
A = "Станислав_Саженов" ;
false.
```

## Определение степени родства

Предикат `relative(Relation, X, Y)` эквивалентен вопросу "Кто Y для X?"

В данном предикате происходит определение родства двух конкретных индивидуумов.

При определении произвольной степени родства сперва проверяются тривиальные случаи, например:
```prolog
relative(["father"], X, Y, _) :- parent(Y, X), sex(Y, m).
relative(["mother"], X, Y, _) :- parent(Y, X), sex(Y, f).
relative(["daughter"], X, Y, _) :- parent(X, Y), sex(Y, f).
relative(["son"], X, Y, _) :- parent(X, Y), sex(Y, m).
```
Когда совпадений не нашлось, необходимо искать более глубокие связи родства и для этого используется предикат:
```prolog
relative([H1|Deep], X, Y, N) :- N = 'deep',
    relative(Deep, X, Int, 'deep'), X \= Int,
    relative(H, Int, Y, 'head'), Y \= Int, X \= Y, [H1|[]]=H.
```
Данный предикат определяет для X человека, который является каким либо родственником ему, и пытаемся определить степень родства этого человека для Y. Чтобы избежать циклов и малочитаемых сложных решений на ранних стадиях поиска, поиск для Y осуществляется поверхностно, без захода в рекурсивную функцию опеределения родства. Полнота вывода от этого не страдает. Бесконечное количество ответов от такого решения оптимизации не уменьшилось. Однако удобочитаемость и простота ответов повысилась, поскольку подобный поиск очень похож на обход графа с итерационным заглублением, в котором величина спуска равна 1, таким спуском обусловливается последовательное увеличение количества слов в ответе.


## Естественно-языковый интерфейс

Естественно-языковой интерфейс реализован для 4-х видов вопросов: 
```prolog
parse_question(X) --> n1r_q(X). % Who is N R
parse_question(X) --> n2r_q(X). % Whose R is N  
parse_question(X) --> rn1n2_q(X). % What kind/type relations between N1 and N2
parse_question(X) --> num_q(X). % How many R does/did/do N have
```
1. Кто является R для N?(пример: `who is Константин_Саженов brother?`)
2. Чьим R является N?(пример: `whose brother is Константин_Саженов?`)
3. Какие отношения между N1 и N2?(пример: `what kind relations between Константин_Саженов and Диана_Николаевская?`)
4. Сколько R имеет N?(пример: `how many brothers does Константин_Саженов have?`)

Разбор грамматики и генерация ответа является довольно объемным, однако не таким сложным в понимании процессом:
1. Для начала происходит разбиение строки на список строк
2. Затем происходит определение модели вопроса(один из четырех типов, приведенных выше):
    1. Процессу парсинга вопроса соответствует одна из моделей, реализованной с помощью предиката в DCG-нотации. Ниже приведены все модели.
    2. Происходит поиск ключевых слов и запись их в compound term.
3. Затем происходит "упрощение" модели:
    1. В каждом предикате существуют некоторые вспомогательные предикаты, которые упрощают обработку различных форм слов и/или обработки, собственно, имен и местоимений.
    2. Происходит сопостваление местоимений, если данные уже были записаны ранее(стоит отметить, что лучше не использовать данную возможность в вопросах с двумям людьми, поскольку велик шанс зацикливания на "самого себя"(при условии одинакового пола)).
    3. Модель вопроса после этого этапа полностью валидна и можно начинать искать ответ.
4. Происходит генерация ответа для каждой из модели(используя некоторые вспомогательные предикаты для того, чтобы сделать ответ читаемым для человека).

Предикат `ask_question` повторяет вышеприведенные пункты:
```prolog
ask_question(R) :-
    ask_question(R, Ans),
    print_res(Ans).

ask_question(R, Ans) :-
    read_string_to_list(R, A),
    parse_question(Model, A, []),
    parse_model(Model, Args),
    generate_ans(Args, Ans).
```

Предикаты моделей в DCG нотации:
```prolog
n1r_q(n1r_q(W1, W2, W3)) -->
    q_word(W1, n1r_q),
    add_verb(be_forms),
    person(W2, posessive, []),
    rec_relative(W3, _).


n1r_q(n1r_q(W1, W3, W2)) -->
    q_word(W1, n1r_q),
    add_verb(be_forms),
    article,
    rec_relative(W2, _),
    ["of"],
    person(W3, common, []).

n2r_q(n2r_q(W1, W2, W3)) -->
    q_word(W1, n2r_q),
    rec_relative(W3, _),
    add_verb(be_forms),
    person(W2, common, []).


rn1n2_q(rn1n2_q(W1, W2, W3)) -->
    q_word(W1, rn1n2_q1),
    [X], {member(X, ["kind", "type"])},
    ["relations", "between"],
    person(W2, common, []),
    ["and"],
    person(W3, common, []).

rn1n2_q(rn1n2_q(W1, W2, W3)) -->
    q_word(W1, rn1n2_q2),
    add_verb(be_forms),
    person(W2, common, []),
    ["for"],
    person(W3, common, []).


num_q(num_q(W1, W2, W3)) -->
    q_word(W1, num_q),
    rec_relative(W2, _),
    add_verb(do_forms),
    person(W3, common, []),
    [X1], {string_lower(X1, X), member(X, ["have", "had"])}.
```


Примеры работы:
```prolog
[debug]  ?- ask_question("What kind relations between Константин_Саженов and Диана_Николаевская?").
Диана_Николаевская is daughter of daughter of sister of mother of father of Константин_Саженов
true ;
Диана_Николаевская is daughter of daughter of sister of wife of father of father of Константин_Саженов
true .

[debug]  ?- ask_question("Who is Константин_Саженов's brother?").
[Who,is,Константин_Саженов's,brother]
The brother of Константин_Саженов is Роман_Саженов
true ;
The brother of Константин_Саженов is Глеб_Саженов
true ;
false.

[debug]  ?- ask_question("How many brothers does Константин_Саженов have?").
[How,many,brothers,does,Константин_Саженов,have]
Константин_Саженов has 2 brothers
true ;
false.

[debug]  ?- ask_question("whose brother is Константин_Саженов?").
[whose,brother,is,Константин_Саженов]
Константин_Саженов is brother of Роман_Саженов
true ;
Константин_Саженов is brother of Глеб_Саженов
true ;
false.

[debug]  ?- ask_question("what kind relations between Константин_Саженов and Диана_Николаевская?").
[what,kind,relations,between,Константин_Саженов,and,Диана_Николаевская]
Диана_Николаевская is daughter of daughter of sister of mother of father of Константин_Саженов
true .
```

## Выводы

Проделав данную курсовую работу, я научился представлять графы в виде предиактов на прологе, изучил некоторые способы поиска решений в графе, такие как поиск в глубину, ширину и с итеративным заглублением, а также погрузился в изучение синтаксического разбора предложений и морфологического разбора слов, для понимания, какой вопрос поступил и как следует отвечать на него в человеко-читаемой форме.

Я столкнулся с трудностями в реализации естественно-языкового интерфейса, поскольку я поначалу не до конца понял задания и предполагал, что программа должна обрабатывать абсолютно все возможные предложения корректно(под "корректно" я подразумевал ответы на заданные вопросы, в случае если человек данный вопрос расценивает как правильный вопрос моей системе с точки зрения семантики), однако, как оказалось, можно использовать некоторые абстрактные шаблоны, дабы упростить данную задачу, поскольку реализовать программу за курс с уже имеющимися знаниями, практически невозможно из-за огромного количества теории, которую следует изучить для решения данной задачи. 

Архитектура, которую имеет данная работа, оказалась очень удобной и применимой в контексте семантического разбора предложения, поскольку ее можно легко дополнить, добавлением пары предикатов и/или ключевых слов, хотя, однако, она не может обрабатывать "абсолютно все" вопросы(что, впрочем, полагаю, не может ни одна система с количеством строк кода менее 1000), что, безусловно, является некоторым минусом данной программы.
